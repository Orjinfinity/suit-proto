// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductPrice {
    #[prost(string, tag="1")]
    pub unit_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub price: ::core::option::Option<super::super::common::v1::Money>,
    #[prost(string, tag="3")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductVariant {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, repeated, tag="4")]
    pub prices: ::prost::alloc::vec::Vec<ProductPrice>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductInput {
    #[prost(string, tag="1")]
    pub sku: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub barcode: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub category_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub name: ::core::option::Option<super::super::common::v1::Translation>,
    #[prost(message, optional, tag="5")]
    pub description: ::core::option::Option<super::super::common::v1::Translation>,
    #[prost(message, repeated, tag="6")]
    pub prices: ::prost::alloc::vec::Vec<ProductPrice>,
    #[prost(enumeration="ProductType", tag="7")]
    pub r#type: i32,
    #[prost(message, repeated, tag="8")]
    pub variants: ::prost::alloc::vec::Vec<ProductVariant>,
    #[prost(string, repeated, tag="9")]
    pub recipe_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="10")]
    pub image_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="11")]
    pub track_inventory: bool,
    #[prost(bool, tag="12")]
    pub allow_out_of_stock_sale: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductView {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub name: ::core::option::Option<super::super::common::v1::Translation>,
    #[prost(message, optional, tag="3")]
    pub description: ::core::option::Option<super::super::common::v1::Translation>,
    #[prost(double, tag="4")]
    pub price: f64,
    #[prost(bool, tag="5")]
    pub is_active: bool,
    #[prost(int64, tag="6")]
    pub created_at: i64,
    #[prost(int64, tag="7")]
    pub updated_at: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProductType {
    Unspecified = 0,
    Simple = 1,
    Variant = 2,
    Recipe = 3,
    Service = 4,
}
impl ProductType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProductType::Unspecified => "PRODUCT_TYPE_UNSPECIFIED",
            ProductType::Simple => "PRODUCT_TYPE_SIMPLE",
            ProductType::Variant => "PRODUCT_TYPE_VARIANT",
            ProductType::Recipe => "PRODUCT_TYPE_RECIPE",
            ProductType::Service => "PRODUCT_TYPE_SERVICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRODUCT_TYPE_SIMPLE" => Some(Self::Simple),
            "PRODUCT_TYPE_VARIANT" => Some(Self::Variant),
            "PRODUCT_TYPE_RECIPE" => Some(Self::Recipe),
            "PRODUCT_TYPE_SERVICE" => Some(Self::Service),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductRequest {
    #[prost(message, optional, tag="1")]
    pub product: ::core::option::Option<ProductInput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductResponse {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub product: ::core::option::Option<ProductInput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateProductResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProductRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteProductResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductResponse {
    #[prost(message, optional, tag="1")]
    pub product: ::core::option::Option<ProductView>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListProductsRequest {
    #[prost(int32, tag="1")]
    pub page: i32,
    #[prost(int32, tag="2")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<ProductView>,
    #[prost(int32, tag="2")]
    pub total: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchProductsRequest {
    #[prost(string, tag="1")]
    pub keyword: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub page: i32,
    #[prost(int32, tag="3")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchProductsResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<ProductView>,
    #[prost(int32, tag="2")]
    pub total: i32,
}
include!("projectsuit.product.v1.tonic.rs");
// @@protoc_insertion_point(module)